<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import

class poloniex extends \ccxt\async\poloniex {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'has' => array(
                'ws' => true,
                'watchTicker' => true,
                'watchTickers' => false, // for now
                'watchTrades' => true,
                'watchOrderBook' => true,
                'watchBalance' => false, // not implemented yet
                'watchOHLCV' => false, // missing on the exchange side
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://api2.poloniex.com',
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'symbolsByOrderId' => array(),
            ),
        ));
    }

    public function handle_tickers($client, $message) {
        //
        //     array(
        //         1002,
        //         null,
        //         array(
        //             50,               // currency pair id
        //             '0.00663930',     // $last trade price
        //             '0.00663924',     // lowest ask
        //             '0.00663009',     // highest bid
        //             '0.01591824',     // percent $change in $last 24 hours
        //             '176.03923205',   // 24h base volume
        //             '26490.59208176', // 24h quote volume
        //             0,                // is frozen
        //             '0.00678580',     // highest price
        //             '0.00648216'      // lowest price
        //         )
        //     )
        //
        $channelId = $this->safe_string($message, 0);
        $subscribed = $this->safe_value($message, 1);
        if ($subscribed) {
            // skip subscription confirmation
            return;
        }
        $ticker = $this->safe_value($message, 2);
        $numericId = $this->safe_string($ticker, 0);
        $market = $this->safe_value($this->options['marketsByNumericId'], $numericId);
        if ($market === null) {
            // todo handle $market not found, reject corresponging futures
            return;
        }
        $symbol = $this->safe_string($market, 'symbol');
        $timestamp = $this->milliseconds();
        $open = null;
        $change = null;
        $average = null;
        $last = $this->safe_float($ticker, 1);
        $relativeChange = $this->safe_float($ticker, 4);
        if ($relativeChange !== -1) {
            $open = $last / $this->sum(1, $relativeChange);
            $change = $last - $open;
            $average = $this->sum($last, $open) / 2;
        }
        $result = array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_float($ticker, 8),
            'low' => $this->safe_float($ticker, 9),
            'bid' => $this->safe_float($ticker, 3),
            'bidVolume' => null,
            'ask' => $this->safe_float($ticker, 2),
            'askVolume' => null,
            'vwap' => null,
            'open' => $open,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => $change,
            'percentage' => $relativeChange * 100,
            'average' => $average,
            'baseVolume' => $this->safe_float($ticker, 6),
            'quoteVolume' => $this->safe_float($ticker, 5),
            'info' => $ticker,
        );
        $this->tickers[$symbol] = $result;
        $messageHash = $channelId . ':' . $numericId;
        $client->resolve ($result, $messageHash);
    }

    public function subscribe_private($messageHash, $subscription) {
        $channelId = '1000';
        $url = $this->urls['api']['ws'];
        $client = $this->client($url);
        if (!(is_array($client->subscriptions) && array_key_exists($channelId, $client->subscriptions))) {
            $this->spawn(array($this, 'fetch_and_cache_open_orders'));
        }
        $nonce = $this->nonce();
        $payload = $this->urlencode(array( 'nonce' => $nonce ));
        $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha512');
        $subscribe = array(
            'command' => 'subscribe',
            'channel' => $channelId,
            'key' => $this->apiKey,
            'payload' => $payload,
            'sign' => $signature,
        );
        return yield $this->watch($url, $messageHash, $subscribe, $channelId, $subscription);
    }

    public function watch_balance($params = array ()) {
        $this->check_required_credentials();
        yield $this->load_markets();
        $url = $this->urls['api']['ws'];
        $client = $this->client($url);
        $messageHash = 'balance';
        $channelId = '1000';
        $existingSubscription = $this->safe_value($client->subscriptions, $channelId, array());
        $fetchedBalance = $this->safe_value($existingSubscription, 'fetchedBalance', false);
        if (!$fetchedBalance) {
            $this->balance = yield $this->fetch_balance();
            $existingSubscription['fetchedBalance'] = true;
        }
        return yield $this->subscribe_private($messageHash, $existingSubscription);
    }

    public function fetch_and_cache_open_orders() {
        // a cancel order update does not give us very much information
        // about an order, we cache the information before receiving cancel updates
        $openOrders = yield $this->fetch_open_orders();
        $orders = $this->orders;
        $symbolsByOrderId = $this->safe_value($this->options, 'symbolsByOrderId', array());
        if ($orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $orders = new ArrayCacheBySymbolById ($limit);
            $this->orders = $orders;
        }
        for ($i = 0; $i < count($openOrders); $i++) {
            $openOrder = $openOrders[$i];
            $orders->append ($openOrder);
            $symbolsByOrderId[$openOrder->id] = $openOrder->symbol;
        }
        $this->options['symbolsByOrderId'] = $symbolsByOrderId;
    }

    public function watch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->check_required_credentials();
        yield $this->load_markets();
        $messageHash = 'orders';
        if ($symbol) {
            $marketId = $this->market_id($symbol);
            $messageHash = $messageHash . ':' . $marketId;
        }
        $orders = yield $this->subscribe_private($messageHash, array());
        if ($this->newUpdates) {
            $limit = $orders->getLimit ();
        }
        return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit);
    }

    public function watch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->check_required_credentials();
        yield $this->load_markets();
        $messageHash = 'myTrades';
        if ($symbol) {
            $marketId = $this->market_id($symbol);
            $messageHash = $messageHash . ':' . $marketId;
        }
        $trades = yield $this->subscribe_private($messageHash, array());
        if ($this->newUpdates) {
            $limit = $trades->getLimit ();
        }
        return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit);
    }

    public function watch_ticker($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $numericId = $this->safe_string($market, 'numericId');
        $channelId = '1002';
        $messageHash = $channelId . ':' . $numericId;
        $url = $this->urls['api']['ws'];
        $subscribe = array(
            'command' => 'subscribe',
            'channel' => $channelId,
        );
        return yield $this->watch($url, $messageHash, $subscribe, $channelId);
    }

    public function watch_tickers($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $channelId = '1002';
        $messageHash = $channelId;
        $url = $this->urls['api']['ws'];
        $subscribe = array(
            'command' => 'subscribe',
            'channel' => $channelId,
        );
        $tickers = yield $this->watch($url, $messageHash, $subscribe, $channelId);
        return $this->filter_by_array($tickers, 'symbol', $symbols);
    }

    public function load_markets($reload = false, $params = array ()) {
        $markets = yield parent::load_markets($reload, $params);
        $marketsByNumericId = $this->safe_value($this->options, 'marketsByNumericId');
        if (($marketsByNumericId === null) || $reload) {
            $marketsByNumericId = array();
            for ($i = 0; $i < count($this->symbols); $i++) {
                $symbol = $this->symbols[$i];
                $market = $this->markets[$symbol];
                $numericId = $this->safe_string($market, 'numericId');
                $marketsByNumericId[$numericId] = $market;
            }
            $this->options['marketsByNumericId'] = $marketsByNumericId;
        }
        $currenciesByNumericId = $this->safe_value($this->options, 'marketsByNumericId');
        if (($currenciesByNumericId === null) || $reload) {
            $currenciesByNumericId = array();
            $keys = is_array($this->currencies) ? array_keys($this->currencies) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $currency = $this->currencies[$keys[$i]];
                $numericId = $this->safe_string($currency, 'numericId');
                $currenciesByNumericId[$numericId] = $currency;
            }
            $this->options['currenciesByNumericId'] = $currenciesByNumericId;
        }
        return $markets;
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $numericId = $this->safe_string($market, 'numericId');
        $messageHash = 'trades:' . $numericId;
        $url = $this->urls['api']['ws'];
        $subscribe = array(
            'command' => 'subscribe',
            'channel' => $numericId,
        );
        $trades = yield $this->watch($url, $messageHash, $subscribe, $numericId);
        if ($this->newUpdates) {
            $limit = $trades->getLimit ($symbol, $limit);
        }
        return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $numericId = $this->safe_string($market, 'numericId');
        $messageHash = 'orderbook:' . $numericId;
        $url = $this->urls['api']['ws'];
        $subscribe = array(
            'command' => 'subscribe',
            'channel' => $numericId,
        );
        $orderbook = yield $this->watch($url, $messageHash, $subscribe, $numericId);
        return $orderbook->limit ($limit);
    }

    public function watch_heartbeat($params = array ()) {
        yield $this->load_markets();
        $channelId = '1010';
        $url = $this->urls['api']['ws'];
        return yield $this->watch($url, $channelId);
    }

    public function handle_heartbeat($client, $message) {
        //
        // every second (approx) if no other updates are sent
        //
        //     array( 1010 )
        //
        $channelId = '1010';
        $client->resolve ($message, $channelId);
    }

    public function handle_trade($client, $trade, $market = null) {
        //
        // public trades
        //
        //     array(
        //         "t", // $trade
        //         "42706057", // $id
        //         1, // 1 = buy, 0 = sell
        //         "0.05567134", // $price
        //         "0.00181421", // $amount
        //         1522877119, // $timestamp
        //     )
        //
        $id = $this->safe_string($trade, 1);
        $isBuy = $this->safe_integer($trade, 2);
        $side = $isBuy ? 'buy' : 'sell';
        $price = $this->safe_float($trade, 3);
        $amount = $this->safe_float($trade, 4);
        $timestamp = $this->safe_timestamp($trade, 5);
        $symbol = null;
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        return array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => $id,
            'order' => null,
            'type' => null,
            'takerOrMaker' => null,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $price * $amount,
            'fee' => null,
        );
    }

    public function handle_order_book_and_trades($client, $message) {
        //
        // first response
        //
        //     [
        //         14, // channelId === $market['numericId']
        //         8767, // $nonce
        //         array(
        //             array(
        //                 "$i", // initial $snapshot
        //                 {
        //                     "currencyPair" => "BTC_BTS",
        //                     "orderBook" => array(
        //                         array( "0.00001853" => "2537.5637", "0.00001854" => "1567238.172367" ), // asks, $price, size
        //                         array( "0.00001841" => "3645.3647", "0.00001840" => "1637.3647" ) // bids
        //                     )
        //                 }
        //             )
        //         )
        //     ]
        //
        // subsequent updates
        //
        //     array(
        //         14,
        //         8768,
        //         array(
        //             array( "o", 1, "0.00001823", "5534.6474" ), // $orderbook $delta, bids, $price, size
        //             array( "o", 0, "0.00001824", "6575.464" ), // $orderbook $delta, asks, $price, size
        //             array( "t", "42706057", 1, "0.05567134", "0.00181421", 1522877119 ) // $trade, id, $side (1 for buy, 0 for sell), $price, size, timestamp
        //         )
        //     )
        //
        $marketId = (string) $message[0];
        $nonce = $message[1];
        $data = $message[2];
        $market = $this->safe_value($this->options['marketsByNumericId'], $marketId);
        $symbol = $this->safe_string($market, 'symbol');
        $orderbookUpdatesCount = 0;
        $tradesCount = 0;
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        for ($i = 0; $i < count($data); $i++) {
            $delta = $data[$i];
            if ($delta[0] === 'i') {
                $snapshot = $this->safe_value($delta[1], 'orderBook', array());
                $sides = array( 'asks', 'bids' );
                $this->orderbooks[$symbol] = $this->order_book();
                $orderbook = $this->orderbooks[$symbol];
                for ($j = 0; $j < count($snapshot); $j++) {
                    $side = $sides[$j];
                    $bookside = $orderbook[$side];
                    $orders = $snapshot[$j];
                    $prices = is_array($orders) ? array_keys($orders) : array();
                    for ($k = 0; $k < count($prices); $k++) {
                        $price = $prices[$k];
                        $amount = $orders[$price];
                        $bookside->store (floatval($price), floatval($amount));
                    }
                }
                $orderbook['nonce'] = $nonce;
                $orderbookUpdatesCount = $this->sum($orderbookUpdatesCount, 1);
            } else if ($delta[0] === 'o') {
                $orderbook = $this->orderbooks[$symbol];
                $side = $delta[1] ? 'bids' : 'asks';
                $bookside = $orderbook[$side];
                $price = floatval($delta[2]);
                $amount = floatval($delta[3]);
                $bookside->store ($price, $amount);
                $orderbookUpdatesCount = $this->sum($orderbookUpdatesCount, 1);
                $orderbook['nonce'] = $nonce;
            } else if ($delta[0] === 't') {
                $trade = $this->handle_trade($client, $delta, $market);
                $stored->append ($trade);
                $tradesCount = $this->sum($tradesCount, 1);
            }
        }
        if ($orderbookUpdatesCount) {
            // resolve the $orderbook future
            $messageHash = 'orderbook:' . $marketId;
            $orderbook = $this->orderbooks[$symbol];
            $client->resolve ($orderbook, $messageHash);
        }
        if ($tradesCount) {
            // resolve the trades future
            $messageHash = 'trades:' . $marketId;
            // todo => incremental trades
            $client->resolve ($stored, $messageHash);
        }
    }

    public function handle_account_notifications($client, $message) {
        // array(
        //   1000,
        //   '',
        //   array(
        //     array(
        //       'p',
        //       898860801559,
        //       121,
        //       '48402.31639500',
        //       '0.00004133',
        //       '0',
        //       null
        //     ),
        //     array( 'b', 28, 'e', '-0.00004133' ),
        //     array( 'b', 214, 'e', '1.99915833' ),
        //     array(
        //       't',
        //       42365437,
        //       '48431.17368463',
        //       '0.00004133',
        //       '0.00125000',
        //       0,
        //       898860801559,
        //       '0.00242155',
        //       '2021-03-06 20:01:23',
        //       null,
        //       '0.00004133'
        //     )
        //   )
        // )
        $data = $this->safe_value($message, 2, array());
        // order is important here
        $methods = array(
            'b' => array( array($this, 'handle_balance')),
            'p' => array( array($this, 'handle_order'), array($this, 'handle_balance')),
            'n' => array( array($this, 'handle_order'), array($this, 'handle_balance')),
            'o' => array( array($this, 'handle_order'), array($this, 'handle_balance')),
            't' => array( array($this, 'handle_my_trade'), array($this, 'handle_order'), array($this, 'handle_balance')),
        );
        for ($i = 0; $i < count($data); $i++) {
            $entry = $data[$i];
            $type = $this->safe_string($entry, 0);
            $callbacks = $this->safe_value($methods, $type);
            if (gettype($callbacks) === 'array' && count(array_filter(array_keys($callbacks), 'is_string')) == 0) {
                for ($j = 0; $j < count($callbacks); $j++) {
                    $callback = $callbacks[$j];
                    $callback($client, $entry);
                }
            }
        }
    }

    public function handle_balance($client, $message) {
        //
        // balance update
        // array( 'b', 28, 'e', '-0.00004133' )
        // array( 'b', 214, 'e', '1.99915833' )
        //
        // pending
        // array( 'p', 6083059, 148, '48402.31639500', '0.00004133', '0', null )
        //
        // new order
        // ["n", 148, 6083059, 1, "0.03000000", "2.00000000", "2018-09-08 04:54:09", "2.00000000", "12345"]
        // ["n", <$currency pair id>, <order number>, <order type>, "<rate>", "<amount>", "<date>", "<original amount ordered>" "<clientOrderId>"]
        //
        // order change
        // array( 'o', 899641758820, '0.00000000', 'c', null, '0.00001971' )
        // [ 'o', 6083059, '1.50000000', 'f', '12345']
        //
        // ["o", <order number>, "<new amount>", "<order type>", "<clientOrderId>"]
        //
        // trade update
        //
        // ["t", 12345, "0.03000000", "0.50000000", "0.00250000", 0, 6083059, "0.00000375", "2018-09-08 05:54:09", "12345", "0.015"]
        //
        // ["t", <trade ID>, "<rate>", "<amount>", "<fee multiplier>", <funding type>, <order number>, <total fee>, <date>, "<clientOrderId>", "<trade total>"]
        //
        $subscription = $this->safe_value($client->subscriptions, '1000', array());
        $fetchedBalance = $this->safe_value($subscription, 'fetchedBalance', false);
        // to avoid synchronisation issues
        if (!$fetchedBalance) {
            return;
        }
        $messageHash = 'balance';
        $messageType = $this->safe_string($message, 0);
        if ($messageType === 'b') {
            $balanceType = $this->safe_string($message, 2);
            if ($balanceType !== 'e') {
                // no support for poloniex futures atm
                return;
            }
            $numericId = $this->safe_string($message, 1);
            $currency = $this->safe_value($this->options['currenciesByNumericId'], $numericId);
            if ($currency === null) {
                return;
            }
            $code = $currency['code'];
            $changeAmount = $this->safe_float($message, 3);
            $this->balance[$code]['free'] = $this->sum($this->balance[$code]['free'], $changeAmount);
            $this->balance[$code]['total'] = null;
            $this->balance = $this->parse_balance($this->balance);
        } else if (($messageType === 'o') || ($messageType === 'p') || ($messageType === 't') || ($messageType === 'n')) {
            $symbol = null;
            $orderId = null;
            if (($messageType === 'o') || ($messageType === 'p')) {
                $orderId = $this->safe_string($message, 1);
                $orderType = $this->safe_string($message, 3);
                if (($messageType === 'o') && ($orderType === 'f')) {
                    // we use the trades for the fills and the order events for the cancels
                    return;
                }
            } else if ($messageType === 't') {
                $orderId = $this->safe_string($message, 6);
            } else if ($messageType === 'n') {
                $orderId = $this->safe_string($message, 2);
            }
            $symbolsByOrderId = $this->safe_value($this->options, 'symbolsByOrderId');
            $symbol = $this->safe_string($symbolsByOrderId, $orderId);
            if (!(is_array($this->markets) && array_key_exists($symbol, $this->markets))) {
                return;
            }
            $market = $this->market($symbol);
            $previousOrders = $this->safe_value($this->orders.hashmap, $symbol, array());
            $previousOrder = $this->safe_value($previousOrders, $orderId);
            $quote = $market['quote'];
            $changeAmount = null;
            if ($messageType === 'n') {
                $changeAmount = $previousOrder['filled'];
            } else if ($messageType === 'o') {
                $changeAmount = $this->safe_float($message, 5);
            } else {
                $changeAmount = $previousOrder['amount'];
            }
            $quoteAmount = $changeAmount * $previousOrder['price'];
            $base = $market['base'];
            $baseAmount = $changeAmount;
            $orderAmount = null;
            $orderCode = null;
            if ($previousOrder['side'] === 'buy') {
                $orderAmount = $quoteAmount;
                $orderCode = $quote;
            } else {
                $orderAmount = $baseAmount;
                $orderCode = $base;
            }
            $preciseAmount = $this->amount_to_precision($symbol, $orderAmount);
            $floatAmount = floatval($preciseAmount);
            if (($messageType === 'o') || ($messageType === 't') || ($messageType === 'n')) {
                $this->balance[$orderCode]['used'] = $this->balance[$orderCode]['used'] - $floatAmount;
            } else {
                $this->balance[$orderCode]['used'] = $this->sum($this->balance[$orderCode]['used'], $floatAmount);
            }
            $this->balance[$orderCode]['total'] = null;
            $this->balance = $this->parse_balance($this->balance);
        }
        $client->resolve ($this->balance, $messageHash);
    }

    public function handle_order($client, $message) {
        //
        // pending
        // array( 'p', 6083059, 148, '48402.31639500', '0.00004133', '0', null ),
        // ["p", <order number>, <currency pair id>, "<rate>", "<$amount>", "<order $type>", "<$clientOrderId>"]
        //
        // new order
        // ["n", 148, 6083059, 1, "0.03000000", "2.00000000", "2018-09-08 04:54:09", "2.00000000", "12345"]
        // ["n", <currency pair id>, <order number>, <order $type>, "<rate>", "<$amount>", "<$date>", "<original $amount ordered>" "<$clientOrderId>"]
        //
        // order change
        // array( 'o', 899641758820, '0.00000000', 'c', null, '0.00001971' )
        // [ 'o', 6083059, '1.50000000', 'f', '12345']
        // ["o", <order number>, "<new $amount>", "c", "<$clientOrderId>", "<canceledAmount>"]
        //
        // $trade change
        // ["t", 12345, "0.03000000", "0.50000000", "0.00250000", 0, 6083059, "0.00000375", "2018-09-08 05:54:09", "12345", "0.015"]
        // ["t", <$trade ID>, "<rate>", "<$amount>", "<fee multiplier>", <funding $type>, <order number>, <total fee>, <$date>, "<$clientOrderId>", "<$trade total>"]
        //
        // in the case of an n update, as corresponding t update is not sent, the code accounts for this
        //
        $orders = $this->orders;
        $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
        $symbolsByOrderId = $this->safe_value($this->options, 'symbolsByOrderId', array());
        if ($orders === null) {
            $orders = new ArrayCacheBySymbolById ($limit);
            $this->orders = $orders;
        }
        $length = is_array($orders) ? count($orders) : 0;
        $type = $this->safe_string($message, 0);
        $symbol = null;
        if ($type === 'p') {
            $orderId = $this->safe_string($message, 1);
            $numericId = $this->safe_string($message, 2);
            $market = $this->safe_value($this->options['marketsByNumericId'], $numericId);
            if ($market === null) {
                return null;
            }
            $symbol = $market['symbol'];
            $symbolsByOrderId[$orderId] = $symbol;
            $price = $this->safe_float($message, 3);
            $amount = $this->safe_float($message, 4);
            $orderType = $this->safe_integer($message, 5);
            $side = $orderType ? 'buy' : 'sell';
            $clientOrderId = $this->safe_string($message, 6);
            if ($length === $limit) {
                $first = $orders[0];
                if (is_array($symbolsByOrderId) && array_key_exists($first['id'], $symbolsByOrderId)) {
                    unset($symbolsByOrderId[$first['id']]);
                }
            }
            $orders->append (array(
                'info' => $message,
                'symbol' => $symbol,
                'id' => $orderId,
                'clientOrderId' => $clientOrderId,
                'timestamp' => null,
                'datetime' => null,
                'lastTradeTimestamp' => null,
                'type' => 'limit',
                'timeInForce' => null,
                'postOnly' => null,
                'side' => $side,
                'price' => $price,
                'stopPrice' => null,
                'amount' => $amount,
                'cost' => null,
                'average' => null,
                'filled' => null,
                'remaining' => $amount,
                'status' => 'open',
                'fee' => null,
                'trades' => null,
            ));
        } else if ($type === 'n') {
            $numericId = $this->safe_string($message, 1);
            $market = $this->safe_value($this->options['marketsByNumericId'], $numericId);
            if ($market === null) {
                return null;
            }
            $symbol = $market['symbol'];
            $orderId = $this->safe_string($message, 2);
            $orderType = $this->safe_integer($message, 3);
            $side = $orderType ? 'buy' : 'sell';
            $price = $this->safe_float($message, 4);
            $remaining = $this->safe_float($message, 5);
            $date = $this->safe_string($message, 6);
            $timestamp = $this->parse8601($date);
            $amount = $this->safe_float($message, 7);
            $clientOrderId = $this->safe_string($message, 8);
            $filled = null;
            $cost = null;
            if (($amount !== null) && ($remaining !== null)) {
                $filled = $amount - $remaining;
                $cost = $filled * $price;
            }
            if ($length === $limit) {
                $first = $orders[0];
                if (is_array($symbolsByOrderId) && array_key_exists($first['id'], $symbolsByOrderId)) {
                    unset($symbolsByOrderId[$first['id']]);
                }
            }
            $orders->append (array(
                'info' => $message,
                'symbol' => $symbol,
                'id' => $orderId,
                'clientOrderId' => $clientOrderId,
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'lastTradeTimestamp' => null,
                'type' => 'limit',
                'timeInForce' => null,
                'postOnly' => null,
                'side' => $side,
                'price' => $price,
                'stopPrice' => null,
                'amount' => $amount,
                'cost' => $cost,
                'average' => null,
                'filled' => $filled,
                'remaining' => $remaining,
                'status' => 'open',
                'fee' => null,
                'trades' => null,
            ));
        } else if ($type === 'o') {
            $orderId = $this->safe_string($message, 1);
            $orderType = $this->safe_string($message, 3);
            if (($orderType === 'c') || ($orderType === 'k')) {
                $symbol = $this->safe_string($symbolsByOrderId, $orderId);
                $previousOrders = $this->safe_value($orders->hashmap, $symbol, array());
                $previousOrder = $this->safe_value($previousOrders, $orderId);
                if ($previousOrder !== null) {
                    $previousOrder['status'] = 'canceled';
                }
            }
        } else if ($type === 't') {
            $trade = $this->parse_ws_trade($message);
            $orderId = $this->safe_string($trade, 'order');
            $symbol = $this->safe_string($symbolsByOrderId, $orderId);
            $previousOrders = $this->safe_value($orders->hashmap, $symbol, array());
            $previousOrder = $this->safe_value($previousOrders, $orderId);
            if ($previousOrder['trades'] === null) {
                $previousOrder['trades'] = array();
            }
            $previousOrder['trades'][] = $trade;
            $filled = $previousOrder['filled'];
            if ($filled === null) {
                $filled = $trade['amount'];
            } else {
                $filled = $previousOrder['filled'] . $trade['amount'];
            }
            if ($previousOrder['amount'] !== null) {
                $previousOrder['remaining'] = max ($previousOrder['amount'] - $filled, 0.0);
                if ($previousOrder['remaining'] === 0.0) {
                    $previousOrder['status'] = 'closed';
                }
            }
            $previousOrder['filled'] = $filled;
            $previousOrder['cost'] = $filled * $previousOrder['price'];
            if ($previousOrder['fee'] === null) {
                $previousOrder['fee'] = array(
                    'currency' => $trade['fee']['currency'],
                    'cost' => $trade['fee']['cost'],
                );
            } else {
                $previousOrder['fee']['cost'] = $this->sum($previousOrder['fee']['cost'], $trade['fee']['cost']);
            }
        }
        $messageHash = 'orders';
        $client->resolve ($orders, $messageHash);
        $symbolSpecificMessageHash = $messageHash . ':' . $symbol;
        $client->resolve ($orders, $symbolSpecificMessageHash);
    }

    public function handle_my_trade($client, $message) {
        //
        // ["t", 12345, "0.03000000", "0.50000000", "0.00250000", 0, 6083059, "0.00000375", "2018-09-08 05:54:09", "12345", "0.015"]
        // ["t", <trade ID>, "<rate>", "<amount>", "<fee multiplier>", <funding type>, <order number>, <total fee>, <date>, "<clientOrderId>", "<trade total>"]
        //
        // in the case of an n update, as corresponding t update is not sent, the code accounts for this
        // so it is possible to miss myTrade updates
        //
        $trades = $this->myTrades;
        if ($trades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $trades = new ArrayCacheBySymbolById ($limit);
        }
        $orders = $this->orders;
        if ($orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $orders = new ArrayCacheBySymbolById ($limit);
            $this->orders = $orders;
        }
        $parsed = $this->parse_ws_trade($message);
        $trades->append ($parsed);
        $messageHash = 'myTrades';
        $client->resolve ($trades, $messageHash);
        $symbolSpecificMessageHash = $messageHash . ':' . $parsed['symbol'];
        $client->resolve ($trades, $symbolSpecificMessageHash);
    }

    public function parse_ws_trade($trade) {
        $orders = $this->orders;
        $tradeId = $this->safe_string($trade, 1);
        $price = $this->safe_float($trade, 2);
        $amount = $this->safe_float($trade, 3);
        $feeRate = $this->safe_float($trade, 4);
        $order = $this->safe_string($trade, 6);
        $feeCost = $this->safe_float($trade, 7);
        $date = $this->safe_string($trade, 8);
        $cost = $this->safe_float($trade, 10);
        $timestamp = $this->parse8601($date);
        $symbolsByOrderId = $this->safe_value($this->options, 'symbolsByOrderId', array());
        $symbol = $this->safe_string($symbolsByOrderId, $order);
        $previousOrders = $this->safe_value($orders->hashmap, $symbol, array());
        $previousOrder = $this->safe_value($previousOrders, $order);
        $market = $this->market($symbol);
        $side = $this->safe_string($previousOrder, 'side');
        $feeCurrency = null;
        if ($side === 'buy') {
            $feeCurrency = $market['base'];
        } else {
            $feeCurrency = $market['quote'];
        }
        $fee = array(
            'cost' => $feeCost,
            'rate' => $feeRate,
            'currency' => $feeCurrency,
        );
        return array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => $tradeId,
            'order' => $order,
            'type' => 'limit',
            'takerOrMaker' => null,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        );
    }

    public function handle_message($client, $message) {
        $channelId = $this->safe_string($message, 0);
        $methods = array(
            // '<numericId>' => 'handleOrderBookAndTrades', // Price Aggregated Book
            '1000' => array($this, 'handle_account_notifications'), // Beta
            '1002' => array($this, 'handle_tickers'), // Ticker Data
            // '1003' => null, // 24 Hour Exchange Volume
            '1010' => array($this, 'handle_heartbeat'),
        );
        $method = $this->safe_value($methods, $channelId);
        if ($method === null) {
            $market = $this->safe_value($this->options['marketsByNumericId'], $channelId);
            if ($market === null) {
                return $message;
            } else {
                return $this->handle_order_book_and_trades($client, $message);
            }
        } else {
            $method($client, $message);
        }
    }
}
